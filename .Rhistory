par.strip.text=list(lines=1, cex=0.7),
scales=list(x=list(relation='free', rot=45), y=list(relation='free', rot=45)),
as.table=TRUE,  xlab='True Cause Fraction', ylab='Estimated Cause Fraction',
panel = function(x,y, ...){
panel.xyplot(x, y, ...)
panel.lmline(x, y, col='blue', lty=2)
panel.lmline(c(x,y), c(x,y), col='red')
})
length(unique(dat$gs_text))
unique(dat$gs_text)
library(ggplot2)
a = data.frame(table(datBayes$naiveBayes)); a$source='Bayes'
b = data.frame(table(datBayes$gs_text));    b$source='gs_text'
ab = rbind(a,b)
ab$Var1 <- reorder(ab$Var1, ab$Freq, median)
ggplot(ab, aes(x=Var1, y=Freq, fill=source)) +
geom_bar(position='dodge', stat='identity') +
theme(axis.text.x=element_text(angle=45, hjust=1, vjust=1)) +
labs(x='Cause of Death', y='Count', title='Cause Specific Mortality Counts (estimated and observed)')
ab
sum(ab$Freq)
sum(ab$Freq)/2
ggplot(ab, aes(x=Var1, y=Freq, fill=source)) +
geom_bar(position='dodge', stat='identity') +
theme(axis.text.x=element_text(angle=45, hjust=1, vjust=1)) +
labs(x='Cause of Death', y='CSMF', title='Cause Specific Mortality Counts (estimated and observed)')
a = data.frame(table(datBayes$naiveBayes)); a$source='Bayes'
b = data.frame(table(datBayes$gs_text));    b$source='gs_text'
ab = rbind(a,b)
ab$Var1 <- reorder(ab$Var1, ab$Freq/1587, median)
ggplot(ab, aes(x=Var1, y=Freq, fill=source)) +
geom_bar(position='dodge', stat='identity') +
theme(axis.text.x=element_text(angle=45, hjust=1, vjust=1)) +
labs(x='Cause of Death', y='CSMF', title='Cause Specific Mortality Counts (estimated and observed)')
a = data.frame(table(datBayes$naiveBayes)); a$source='Bayes'
b = data.frame(table(datBayes$gs_text));    b$source='gs_text'
ab = rbind(a,b)
ab$Var1 <- reorder(ab$Var1, ab$Freq, median)
ggplot(ab, aes(x=Var1, y=Freq/1587, fill=source)) +
geom_bar(position='dodge', stat='identity') +
theme(axis.text.x=element_text(angle=45, hjust=1, vjust=1)) +
labs(x='Cause of Death', y='CSMF', title='Cause Specific Mortality Counts (estimated and observed)')
dat[1:10, 1:15]
table(dat$icd_name, dat$causadef)
dat[1:10, 1:15]
head(datBayes)
source('GC Methods.R')
inx      <- dat$icd_name != '_gc'
goodCols <- c(1,4,10,12:17, which(names(dat) %in% c("age", 'ageGroup',"gender", "education", 
"cigsPerDay", 'smokingGroup')))
probObj  <- getMCDTransitionMatrix(x=dat[inx, ], priorFunction='Good-Turing',
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"),
finalCause="gs_text", cofactors=c('gender', 'ageGroup', 'smokingGroup'))
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51")
bestCall.2 <- function(x, mcdCols, cofactors, ...) {
evidence = cleanICDs(unlist(x[ mcdCols ]))
if (! missing(cofactors)) {
for (aCofactor in cofactors) {
evidence <- c(evidence, cleanICDs(paste(aCofactor, as.character(x[,aCofactor]), sep='.')))
}
}
result  = sort(bayesCompute(evidence=evidence, ...)$naiveBayesVec, decreasing=TRUE)
myCall  = names(result)[1]
prob    = result[1]
#print(str(result))
logOdds = log(prob/(sum(result[-1])))
return(c(bestCall=myCall, logOdds=logOdds))
}
bestCall.2(x=dat[16,], mcdCols=mcdCols, cofactors=c('ageGroup', 'gender'), probObj=probObj)
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes <- cbind(datBayes[,1:3], 'naiveBayes'=NA, 'logOdds'=NA, datBayes[,4:ncol(datBayes)]) 
datBayes$naiveBayes <- NA
datBayes$logOdds    <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,c('naiveBayes', 'logOdds')] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
write.csv(datBayes, file='datBayes.csv', quote=FALSE)  # s
save(datBayes, file='datBayes.RData')         
xyplot(I(naiveBayes==gs_text) ~ logOdds | gs_text, data=datBayes)
xyplot(I(naiveBayes==gs_text) ~ logOdds | gs_text, data=datBayes,
scales=list(x=list(relation='free')))
xyplot(jitter(I(naiveBayes==gs_text)) ~ logOdds | gs_text, data=datBayes,
scales=list(x=list(relation='free')))
xyplot(jitter(as.numeric(naiveBayes==gs_text)) ~ logOdds | gs_text, data=datBayes,
scales=list(x=list(relation='free')))
xyplot(jitter(as.numeric(naiveBayes==gs_text)) ~ logOdds | gs_text, data=datBayes,
scales=list(x=list(relation='free')))
str(datBayes)
sum(datBayes$gs_text=='AIDS')
sum(datBayes$naiveBayes=='AIDS')
xyplot(jitter(as.numeric(naiveBayes==gs_text)) ~ logOdds | gs_text, data=datBayes,
subset=gs_text=='AIDS',
scales=list(x=list(relation='free')))
datBayes[datBayes$gs_text=='AIDS',]
glort = as.numeric(datBayes$gs_text == datBayes$naiveBayes)
glort
xyplot(jitter(glort) ~ logOdds | gs_text, data=datBayes,
subset=gs_text=='AIDS',
scales=list(x=list(relation='free')))
xyplot(jitter(glort) ~ logOdds, data=datBayes,
subset=gs_text=='AIDS',
scales=list(x=list(relation='free')))
xyplot(jitter(glort) ~ logOdds, data=datBayes,
scales=list(x=list(relation='free')))
fivenum(datBayes$logOdds)
head(datBayes)
fivenum(datBayes$logOdds)
datBayes$logOdds
str(datBayes)
datBayes$logOdds <- as.numeric(datBayes$logOdds)
str(datBayes)
glort = as.numeric(datBayes$gs_text == datBayes$naiveBayes)
xyplot(jitter(glort) ~ logOdds, data=datBayes,
scales=list(x=list(relation='free')))
xyplot(jitter(glort) ~ logOdds | gs_text, data=datBayes,
scales=list(x=list(relation='free')))
xyplot(jitter(glort) ~ logOdds | gs_text, data=datBayes,
type=c('p', 'smooth'),
as.table=TRUE, par.strip.text=list(lines=0.8, cex=0.7),
scales=list(x=list(relation='free')))
write.csv(datBayes, file='datBayes.csv', quote=FALSE)
save(datBayes, file='datBayes.RData')   
xyplot(jitter(glort) ~ logOdds | gs_text, data=datBayes,
type=c('p', 'smooth'), span=10, 
as.table=TRUE, par.strip.text=list(lines=0.8, cex=0.7),
scales=list(x=list(relation='free')))
xyplot(jitter(glort) ~ logOdds | gs_text, data=datBayes,
type=c('p', 'smooth'), span=1, 
as.table=TRUE, par.strip.text=list(lines=0.8, cex=0.7),
scales=list(x=list(relation='free')))
windows()
xyplot(jitter(glort) ~ logOdds | gs_text, data=datBayes,
type=c('p', 'smooth'), #span=1, 
as.table=TRUE, par.strip.text=list(lines=0.8, cex=0.7),
scales=list(x=list(relation='free')))
warnings()
xyplot(glort ~ logOdds | gs_text, data=datBayes,
type=c('p', 'smooth'), #span=1, 
as.table=TRUE, par.strip.text=list(lines=0.8, cex=0.7),
scales=list(x=list(relation='free')))
xyplot(jitter(glort, amount=0.1) ~ logOdds | gs_text, data=datBayes,
type=c('p', 'smooth'), #span=1, 
as.table=TRUE, par.strip.text=list(lines=0.8, cex=0.7),
scales=list(x=list(relation='free')))
xyplot(jitter(glort, amount=0.02) ~ logOdds | gs_text, data=datBayes,
type=c('p', 'smooth'), #span=1, 
as.table=TRUE, par.strip.text=list(lines=0.8, cex=0.7),
scales=list(x=list(relation='free')))
xyplot(jitter(glort, amount=0.02) ~ logOdds | gs_text, data=datBayes,
type=c('p', 'smooth'), span=1, 
as.table=TRUE, par.strip.text=list(lines=0.8, cex=0.7),
scales=list(x=list(relation='free')))
q()
rm(list=ls())
setwd('C:/Users/John/Desktop/DeathCertificates/')
library(lattice)
library(latticeExtra)
library(plyr)
library(gplots)
library(ggplot2)
library(gtools)       # smartbind  (to bind dfs with different columns)
library(edgeR)        # Good-Turing estimator background for transition matrix
library(MCMCpack)     # Dirichlet sampling
source('GC Methods.R')
# -----------------------------------------------
# Start by reading in the Mexico death certificate data.   This supposedly has the data from 1589 Mexican
# subjects.   These are 'gold standard' reviewed documents and 224 of them are noted as being garbage codes.
# Prep the data in the other script file, 'DeathCertificates_Basic_Data_Shaping_and_Storage.R'
load(file='dat.RData')          # Load the (1587x67) data as processed in earlier
load(file='datBayes.RData')     # In development.   Most recent predictions
load(file='icd10Vec.RData')     # 91,737 ICD-10 definitions
load(file='colDesc.RData')      # Descriptions of the column headers (547 headers as a named vector)
a = calculateCSMF(datBayes$gs_text, datBayes$naiveBayes)
a
ls()
source('GC Methods.R')
categories=c('Stroke', 'AIDS', 'Diabetes', 'Other.Non.communicable.Diseases', 'Breast.Cancer')
categories=c('Stroke', 'AIDS')
csmf  <- cvRun(x=dat, fractions=seq(0, 2, length.out=17), categories=categories, testFraction=0.25)
str(csmf); csmf.bak = csmf
maxFrac <- max(c(csmf$predFrac, csmf$obsFrac), na.rm=TRUE)
xyplot(predFrac ~ obsFrac | cause, data=csmf, 
type=c('p', 'g'), pch=19,
subset=category==cause, #xlim=c(0,maxFrac), ylim=c(0,maxFrac),
par.strip.text=list(lines=1, cex=0.7),
scales=list(x=list(relation='free', rot=45), y=list(relation='free', rot=45)),
as.table=TRUE,  xlab='True Cause Fraction', ylab='Estimated Cause Fraction',
panel = function(x,y, ...){
panel.xyplot(x, y, ...)
panel.lmline(x, y, col='blue', lty=2)
panel.lmline(c(x,y), c(x,y), col='red')
})
head(csmf)
calculateCSMFAccuracy(datBayes$naiveBayes, datBayes$gs_text)
calculateCSMFAccuracy(datBayes$naiveBayes, rep('A', nrow(datBayes)))
calculateCSMFAccuracy(datBayes$gs_text, datBayes$gs_text)
calculateCSMFAccuracy(sample(datBayes$gs_text), datBayes$gs_text)
calculateCSMFAccuracy(sample(datBayes$gs_text, replace=TRUE), datBayes$gs_text)
calculateCSMFAccuracy(sample(datBayes$gs_text, replace=TRUE), datBayes$gs_text)
calculateCSMFAccuracy(sample(datBayes$gs_text, replace=TRUE), datBayes$gs_text)
calculateCSMFAccuracy(sample(datBayes$gs_text, replace=TRUE), datBayes$gs_text)
xyplot(predFrac ~ obsFrac | cause, data=csmf, 
type=c('p', 'g'), pch=19,
subset=category==cause, #xlim=c(0,maxFrac), ylim=c(0,maxFrac),
par.strip.text=list(lines=1, cex=0.7),
scales=list(x=list(relation='free', rot=45), y=list(relation='free', rot=45)),
as.table=TRUE,  xlab='True Cause Fraction', ylab='Estimated Cause Fraction',
panel = function(x,y, ...){
panel.xyplot(x, y, ...)
panel.lmline(x, y, col='red', lty=1)
panel.lmline(c(x,y), c(x,y), col='green', pch=2)
})
xyplot(predFrac ~ obsFrac | cause, data=csmf, 
type=c('p', 'g'), pch=19,
subset=category==cause, #xlim=c(0,maxFrac), ylim=c(0,maxFrac),
par.strip.text=list(lines=1, cex=0.7),
scales=list(x=list(relation='free', rot=45), y=list(relation='free', rot=45)),
as.table=TRUE,  xlab='True Cause Fraction', ylab='Estimated Cause Fraction',
panel = function(x,y, ...){
panel.xyplot(x, y, ...)
panel.lmline(x, y, col='red', lty=1)
panel.lmline(c(x,y), c(x,y), col='green', lty=2)
})
datBayes[5:30,]
datBayes[datBayes$gs_text=='Stillbirth',]
table(subset(datBayes, subset=age==0, select=gs_text))
sort(table(subset(datBayes, subset=age==0, select=gs_text)))
subset(datBayes, subset=age==0)
source('GC Methods.R')
inx      <- dat$icd_name != '_gc'
goodCols <- c(1,4,10,12:17, which(names(dat) %in% c("age", 'ageGroup',"gender", "education", 
"cigsPerDay", 'smokingGroup')))
mcdCols=c("causadef", "codcau11", "codcau21", "codcau31", "codcau41", "codcau51")
probObj  <- getMCDTransitionMatrix(x=dat[inx, ], priorFunction='Good-Turing',
mcdCols=mcdCols, finalCause="gs_text", cofactors=c('gender', 'ageGroup', 'smokingGroup'))
# A minifunction for ddply that takes in 1 line of dat
bestCall.2 <- function(x, mcdCols, cofactors, ...) {
evidence = cleanICDs(unlist(x[ mcdCols ]))
if (! missing(cofactors)) {
for (aCofactor in cofactors) {
evidence <- c(evidence, cleanICDs(paste(aCofactor, as.character(x[,aCofactor]), sep='.')))
}
}
result  = sort(bayesCompute(evidence=evidence, ...)$naiveBayesVec, decreasing=TRUE)
myCall  = names(result)[1]
prob    = result[1]
#print(str(result))
logOdds = log(prob/(sum(result[-1])))
return(c(bestCall=myCall, logOdds=logOdds))
}
bestCall.2(x=dat[16,], mcdCols=mcdCols, cofactors=c('ageGroup', 'gender'), probObj=probObj)
mcdCols=c("causadef", "codcau11", "codcau21", "codcau31", "codcau41", "codcau51")
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes <- cbind(datBayes[,1:3], 'naiveBayes'=NA, 'logOdds'=NA, datBayes[,4:ncol(datBayes)]) 
datBayes$naiveBayes <- NA
datBayes$logOdds    <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,c('naiveBayes', 'logOdds')] <- bestCall.2(x=datBayes[i,], 
mcdCols=mcdCols, 
cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes$gs_text <- make.names(datBayes$gs_text)
datBayes$logOdds <- as.numeric(datBayes$logOdds)
head(datBayes)
glort = as.numeric(datBayes$gs_text == datBayes$naiveBayes)
xyplot(jitter(glort, amount=0.02) ~ logOdds | gs_text, data=datBayes,
type=c('p', 'smooth'), span=1, 
as.table=TRUE, par.strip.text=list(lines=0.8, cex=0.7),
scales=list(x=list(relation='free')))
library(ggplot2)
a = data.frame(table(datBayes$naiveBayes)); a$source='Bayes'
b = data.frame(table(datBayes$gs_text));    b$source='gs_text'
ab = rbind(a,b)
ab$Var1 <- reorder(ab$Var1, ab$Freq, median)
ggplot(ab, aes(x=Var1, y=Freq/1587, fill=source)) +
geom_bar(position='dodge', stat='identity') +
theme(axis.text.x=element_text(angle=45, hjust=1, vjust=1)) +
labs(x='Cause of Death', y='CSMF', title='Cause Specific Mortality Counts (estimated and observed)')
source('GC Methods.R')
categories=c('Stroke', 'AIDS')
csmf  <- cvRun(x=dat, fractions=seq(0, 2, length.out=17), categories=categories, testFraction=0.25)
str(csmf); csmf.bak = csmf
maxFrac <- max(c(csmf$predFrac, csmf$obsFrac), na.rm=TRUE)
xyplot(predFrac ~ obsFrac | cause, data=csmf, 
type=c('p', 'g'), pch=19,
subset=category==cause, #xlim=c(0,maxFrac), ylim=c(0,maxFrac),
par.strip.text=list(lines=1, cex=0.7),
scales=list(x=list(relation='free', rot=45), y=list(relation='free', rot=45)),
as.table=TRUE,  xlab='True Cause Fraction', ylab='Estimated Cause Fraction',
panel = function(x,y, ...){
panel.xyplot(x, y, ...)
panel.lmline(x, y, col='blue', lty=2)
panel.lmline(c(x,y), c(x,y), col='red')
})
table(dat$age)
hist(dat$age)
cumsum(dat$age)
cumsum(table(dat$age))
cumsum(table(dat$age)) - 246
str(dat)
names(dat)
table(dat$age, dat$ageGroup)
table(dat$ageGroup, dat$age)
x = dat
dat[1:7, 'ageGroup'] <- 'Child'
str(dat)
dat[1:20,goodCols]
rm(list=ls())
setwd('C:/Users/John/Desktop/DeathCertificates/')
library(jsonlite)     # .JSON files
library(RJSONIO)
library(gdata)        # Excel files
library(plyr)
library(gtools)       # smartbind  (to bind dfs with different columns)
source('GC Methods.R')
# CREATE AND SAVE A EASY ACCESS DESCRIPTIONS OF THE ICD CODES.
# Comprehensive set of ICD-10 codes and descriptions from the CMS
icd10Vec <- readICDList(aFile='./Data/icd10cm_order_2015.txt')
save(icd10Vec, file='icd10Vec.RData')          # Saving the data at this step.
# CREATE AND SAVE A EASY ACCESS DESCRIPTIONS OF THE VARIOUS COLUMN HEADERS
datColDesc     <- read.csv('./Data/IHME_GC13_VA_DATA_CODEBOOK_Y2013M04D04.csv', header=TRUE, stringsAsFactors=FALSE)
datColDesc     <- datColDesc[nchar(datColDesc$variable) > 0,]
colDesc        <- datColDesc$question
names(colDesc) <- datColDesc$variable
save(colDesc, file='colDesc.RData')
dat          <- read.csv('Data/mccd final_070311.csv', stringsAsFactors=FALSE);  
map_icd      <- fromJSON('./Data/map_icd.json', asText=FALSE)
dat$icd_name <- map_icd[dat$ICD]
# Now I have replicated Abie's things in the first part of:
# file:///C:/Users/John/Desktop/DeathCertificates/2014_01_30a_MEX_MCD_data.html
str(dat); summary(dat)      # 1589 obs. of  11 variables
sort(table(dat$icd_name))   # These are the International Classification of Diseases (224 are '_gc')
# Underlying causes of death.   This is actually a very large amount of information (530+ columns?)
# detailing an interview with one (or more?) surviving members of the deceased's family as well as
# a more thorough report from a pathologist(?).  A key result is the 11th field or so called "gs_text55"
# which has the updated/correct cause of death.   Compare/contrast this to "gs_text" in the first dat file.
#
# Here is the info from Bernardo:
'Abie, finally here is the info on the multiple cause of death DC coding for Mexico, with the dataset used in the 
validation study. I have saved it at:
J:\Project\VA\Archive\MEXICO MCCD
You will find 2 files. One contains only the info on the underlying cause of death and mapping to the VA 
reduced cause list. The other one has all the causes coded. Please note that in this one, the underlying 
cause of death is divided in 2 fields. The final digit of the coding is in the “desdoblado” column. Let me 
know, and if you like we can take a look at these together.'
# FOLD IN EXTENSIVE ADDITIONAL INFORMATION ABOUT EACH SUBJECT
underlyingInfo <- read.xls('./Data/Mexico_base de CD con 1638 registros.xls', sheet=1, header=TRUE, stringsAsFactors=FALSE)
underlyingInfo <- underlyingInfo[, colnames(underlyingInfo)!='X']
inx            <- is.finite(as.numeric(underlyingInfo$desdobla))
underlyingInfo[inx, 'causadef'] <- paste(underlyingInfo[inx, 'causadef'], underlyingInfo[inx, 'desdobla'], sep='')
head(underlyingInfo)
dat <- merge(dat, underlyingInfo, by.x='sid', by.y='Sid')
str(dat)
detailInfo <- NULL
for (aModule in dir('./Data/', pattern=glob2rx('IHME_GC13*csv'), full.names=TRUE)) {
#print(aModule)
temp       <- read.csv(aModule, header=TRUE, stringsAsFactors=FALSE)
cat(aModule, dim(temp), '\n')
detailInfo <- smartbind(detailInfo, temp, verbose=FALSE)
}
detailInfo <- subset(detailInfo, site=='Mexico')
dim(detailInfo)
detailInfo$sid  <- as.numeric(gsub('M-', '', detailInfo$sid))
detailInfo[1:20, 1:10]
detailInfo[sample(nrow(detailInfo),20), sample(ncol(detailInfo),10)]
length(unique(dat$sid))              # 1589 subjects...
length(unique(detailInfo$sid))       # 2031 subjects (More sids in the detailInfo)
# MERGE THE BASIC INFORMATION AND THE DETAILED INFORMATION TOGETHER
# After the next few steps dat is 1586 x 550.
dat <- merge(dat, detailInfo, by='sid')
# CLEAN UP AGE, GENDER AND OTHER THINGS..
dat$age         <- as.numeric(dat$g1_07a)
inx             <- is.na(dat$age)
dat[inx,'age']  <- as.numeric(dat[inx,'g1_06y']) - as.numeric(dat[inx,'g1_01y'])
plot(sort(dat$age)); grid()
#dat$ageGroup   <- cut(dat$age, breaks=c(-2,2,16,50,200), labels=c('Infant', 'Child', 'Adult', 'Senior'))  
dat$ageGroup   <- cut(dat$age, breaks=c(-2,0,11,200), labels=c('Neonate', 'Child', 'Adult'))
dat[dat$c1_26=='Less than 28 days', 'ageGroup']   <- 'Neonate'
dat[dat$c1_26=='28 days to 11 years', 'ageGroup'] <- 'Child'
plot(table(dat$ageGroup))
dat$gender      <- dat$g1_05
dat[nchar(dat$gender)==0,'gender']  <- 'Unknown'
dat$education   <- dat$g1_09
dat[nchar(dat$education)==0,'education']  <- 'Unknown'
dat$education   <- factor(dat$education, levels=c('Unknown', 'No Schooling', 'Primary School', 
'High School', 'College or Higher'))
table(dat$education)
# Tobacco use?   Probably cigarrette use is important with this dataset...
dat[sample(nrow(dat),20),c('a4_01', 'a4_02_1', 'a4_02_2', 'a4_02_3', 'a4_03', 'a4_04')]
plot(sort(dat$a4_04)); grid()
dat$cigsPerDay  <- dat$a4_04
plot(sort(dat$cigsPerDay)); grid()
dat$smokingGroup   <- cut(dat$cigsPerDay, breaks=c(-1,0,10,1000), labels=c('None', 'Light', 'Heavy'))
dat[which(dat$age < 10), 'smokingGroup'] = 'None'
table(dat$smokingGroup, useNA='always')
# Rename it to find it easier
dat$alcohol <- dat$a4_06
table(dat$alcohol, useNA='always')
# KEEP ONLY A SUBSET OF THE GIANT BLOCK OF DATA
# Reduce the columns to some manageable set.  At the top of this file I read in a tab delimited file
# that had explantions for each of the column headers.  I edited the file to include a column
# called 'discard'.  Zero means generally keep it.  1 is extra info.  2 is probably never needed by me.
# Now down to 1587 obs. of  67 variables when the following is executed.
str(datColDesc)
keepCols   <- c("sid", "age", "ageGroup", "gender", "education", "cigsPerDay", 'smokingGroup', 'alcohol',
"source", "module.x", "gs_text", "va_code", "gs_code", "gs_assigned", 
"gs_level.x", "ICD", "icd_name", "foliocer", "causadef", 
"codcau11", "codcau21", "codcau31", "codcau41",  "codcau51", "site", 
"gs_code34", "gs_text34", "va34", "gs_code46", "gs_text46", "va46", "gs_code55", 
"gs_text55", "va55")
keepCols   <- c(keepCols, datColDesc$variable[datColDesc$discard==0])
dat        <- dat[, names(dat) %in% keepCols]
names(dat) <- gsub('\\.x|\\.y$', '', names(dat), perl=TRUE)
# SAVE AND STORE IT IN TWO DIFFERENT FORMATS
save(dat, file='dat.RData')          # Saving the data at this step.
write.csv(dat, file='dat.csv')
str(dat)
table(dat$c1_26)
table(dat$c1_26, exclude='lkj')
table(dat$ageGroup)
dat[is.na(dat$c1_26), 'c1_26']                    <- ''
dat[dat$c1_26=='Less than 28 days', 'ageGroup']   <- 'Neonate'
dat[dat$c1_26=='28 days to 11 years', 'ageGroup'] <- 'Child'
plot(table(dat$ageGroup))
table(dat$ageGroup)
dat          <- read.csv('Data/mccd final_070311.csv', stringsAsFactors=FALSE);  
map_icd      <- fromJSON('./Data/map_icd.json', asText=FALSE)
dat$icd_name <- map_icd[dat$ICD]
# Now I have replicated Abie's things in the first part of:
# file:///C:/Users/John/Desktop/DeathCertificates/2014_01_30a_MEX_MCD_data.html
str(dat); summary(dat)      # 1589 obs. of  11 variables
sort(table(dat$icd_name))   # These are the International Classification of Diseases (224 are '_gc')
# FOLD IN EXTENSIVE ADDITIONAL INFORMATION ABOUT EACH SUBJECT
underlyingInfo <- read.xls('./Data/Mexico_base de CD con 1638 registros.xls', sheet=1, header=TRUE, stringsAsFactors=FALSE)
underlyingInfo <- underlyingInfo[, colnames(underlyingInfo)!='X']
inx            <- is.finite(as.numeric(underlyingInfo$desdobla))
underlyingInfo[inx, 'causadef'] <- paste(underlyingInfo[inx, 'causadef'], underlyingInfo[inx, 'desdobla'], sep='')
head(underlyingInfo)
dat <- merge(dat, underlyingInfo, by.x='sid', by.y='Sid')
str(dat)
detailInfo <- NULL
for (aModule in dir('./Data/', pattern=glob2rx('IHME_GC13*csv'), full.names=TRUE)) {
#print(aModule)
temp       <- read.csv(aModule, header=TRUE, stringsAsFactors=FALSE)
cat(aModule, dim(temp), '\n')
detailInfo <- smartbind(detailInfo, temp, verbose=FALSE)
}
detailInfo <- subset(detailInfo, site=='Mexico')
dim(detailInfo)
detailInfo$sid  <- as.numeric(gsub('M-', '', detailInfo$sid))
detailInfo[1:20, 1:10]
detailInfo[sample(nrow(detailInfo),20), sample(ncol(detailInfo),10)]
length(unique(dat$sid))              # 1589 subjects...
length(unique(detailInfo$sid))       # 2031 subjects (More sids in the detailInfo)
# MERGE THE BASIC INFORMATION AND THE DETAILED INFORMATION TOGETHER
# After the next few steps dat is 1586 x 550.
dat <- merge(dat, detailInfo, by='sid')
# CLEAN UP AGE, GENDER AND OTHER THINGS..
dat$age         <- as.numeric(dat$g1_07a)
inx             <- is.na(dat$age)
dat[inx,'age']  <- as.numeric(dat[inx,'g1_06y']) - as.numeric(dat[inx,'g1_01y'])
plot(sort(dat$age)); grid()
#dat$ageGroup   <- cut(dat$age, breaks=c(-2,2,16,50,200), labels=c('Infant', 'Child', 'Adult', 'Senior'))  
dat$ageGroup   <- cut(dat$age, breaks=c(-2,0,11,200), labels=c('Neonate', 'Child', 'Adult'))
dat[is.na(dat$c1_26), 'c1_26']                    <- ''
dat[dat$c1_26=='Less than 28 days', 'ageGroup']   <- 'Neonate'
dat[dat$c1_26=='28 days to 11 years', 'ageGroup'] <- 'Child'
plot(table(dat$ageGroup))
table(dat$ageGroup)
dat$gender      <- dat$g1_05
dat[nchar(dat$gender)==0,'gender']  <- 'Unknown'
dat$education   <- dat$g1_09
dat[nchar(dat$education)==0,'education']  <- 'Unknown'
dat$education   <- factor(dat$education, levels=c('Unknown', 'No Schooling', 'Primary School', 
'High School', 'College or Higher'))
table(dat$education)
# Tobacco use?   Probably cigarrette use is important with this dataset...
dat[sample(nrow(dat),20),c('a4_01', 'a4_02_1', 'a4_02_2', 'a4_02_3', 'a4_03', 'a4_04')]
plot(sort(dat$a4_04)); grid()
dat$cigsPerDay  <- dat$a4_04
plot(sort(dat$cigsPerDay)); grid()
dat$smokingGroup   <- cut(dat$cigsPerDay, breaks=c(-1,0,10,1000), labels=c('None', 'Light', 'Heavy'))
dat[which(dat$age < 10), 'smokingGroup'] = 'None'
table(dat$smokingGroup, useNA='always')
# Rename it to find it easier
dat$alcohol <- dat$a4_06
table(dat$alcohol, useNA='always')
# KEEP ONLY A SUBSET OF THE GIANT BLOCK OF DATA
# Reduce the columns to some manageable set.  At the top of this file I read in a tab delimited file
# that had explantions for each of the column headers.  I edited the file to include a column
# called 'discard'.  Zero means generally keep it.  1 is extra info.  2 is probably never needed by me.
# Now down to 1587 obs. of  67 variables when the following is executed.
str(datColDesc)
keepCols   <- c("sid", "age", "ageGroup", "gender", "education", "cigsPerDay", 'smokingGroup', 'alcohol',
"source", "module.x", "gs_text", "va_code", "gs_code", "gs_assigned", 
"gs_level.x", "ICD", "icd_name", "foliocer", "causadef", 
"codcau11", "codcau21", "codcau31", "codcau41",  "codcau51", "site", 
"gs_code34", "gs_text34", "va34", "gs_code46", "gs_text46", "va46", "gs_code55", 
"gs_text55", "va55")
keepCols   <- c(keepCols, datColDesc$variable[datColDesc$discard==0])
dat        <- dat[, names(dat) %in% keepCols]
names(dat) <- gsub('\\.x|\\.y$', '', names(dat), perl=TRUE)
# SAVE AND STORE IT IN TWO DIFFERENT FORMATS
save(dat, file='dat.RData')          # Saving the data at this step.
write.csv(dat, file='dat.csv')
q()
