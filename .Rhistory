setwd('C:/Users/John/Desktop/DeathCertificates/')
library(lattice)
library(latticeExtra)
library(plyr)
library(gplots)
library(ggplot2)
library(gtools)       # smartbind  (to bind dfs with different columns)
library(edgeR)        # Good-Turing estimator background for transition matrix
source('GC Methods.R')
# -----------------------------------------------
# Start by reading in the Mexico death certificate data.   This supposedly has the data from 1589 Mexican
# subjects.   These are 'gold standard' reviewed documents and 224 of them are noted as being garbage codes.
# Prep the data in the other script file, 'DeathCertificates_Basic_Data_Shaping_and_Storage.R'
load(file='dat.RData')          # Load the (1587x67) data as processed in earlier
load(file='datBayes.RData')     # In development.   Most recent predictions
load(file='icd10Vec.RData')     # 91,737 ICD-10 definitions
load(file='colDesc.RData')      # Descriptions of the column headers (547 headers as a named vector)
sum(datBayes$gs_text == datBayes$naiveBayes); nrow(datBayes)
ddply(datBayes, .(gs_text), summarize, count=length(gs_text), correct=sum(gs_text==naiveBayes))
ddply(datBayes, .(gs_text), summarize, count=length(gs_text), correct=sum(gs_text==naiveBayes), sens=correct/count)
junk = ddply(datBayes, .(gs_text), summarize, count=length(gs_text), correct=sum(gs_text==naiveBayes), sens=correct/count)
junk = ddply(datBayes, .(gs_text), summarize, count=length(gs_text), correct=sum(gs_text==naiveBayes), sens=correct/count)
plot(junk$count, junk$sens, main='Sensitivty as a function of the number of cases')
abline(reg=lm(junk$sens ~ junk$count), col='red', lty=2)
inx <- datBayes$gs_text == 'Pneumonia'
datBayes[inx,]
datBayes[inx,]
icdGuess(c(J189A419J869J189))
icdGuess(c('J189','A419','J869','J189'))
sum(inx)
junk = ddply(datBayes, .(gs_text), summarize, count=length(gs_text), trainingCount=sum(icd_name!='_gc'),
correct=sum(gs_text==naiveBayes), sens=correct/count)
junk
write.csv(accuCount, file='accuCount.csv', quote=FALSE)  # save it for perusal in Excel & etc
sum(datBayes$gs_text == datBayes$naiveBayes); nrow(datBayes)
accuCount = ddply(datBayes, .(gs_text), summarize, count=length(gs_text), trainingCount=sum(icd_name!='_gc'),
correct=sum(gs_text==naiveBayes), sens=correct/count)
plot(accuCount$count, accuCount$sens, main='Sensitivty as a function of the number of cases')
abline(reg=lm(accuCount$sens ~ accuCount$count), col='red', lty=2)
write.csv(accuCount, file='accuCount.csv', quote=FALSE)  # save it for perusal in Excel & etc
# ==============   AUTO-RUN THE PROCEDURE ON THE WHOLE DATA SET   ==============
source('GC Methods.R')
inx      <- dat$icd_name != '_gc'
probObj  <- getMCDTransitionMatrix(x=dat[inx, ], priorFunction='Good-Turing',
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"),
finalCause="gs_text", cofactors=c('gender', 'ageGroup'))#, 'smokingGroup'))
# ==============   AUTO-RUN THE PROCEDURE ON THE WHOLE DATA SET   ==============
source('GC Methods.R')
inx      <- dat$icd_name != '_gc'
probObj  <- getMCDTransitionMatrix(x=dat[inx, ], priorFunction='Good-Turing',
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"),
finalCause="gs_text", cofactors=c('gender', 'ageGroup', 'smokingGroup'))
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c('ageGroup', 'gender'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
# A minifunction for ddply that takes in 1 line of dat
bestCall.2 <- function(x, mcdCols, cofactors, ...) {
evidence = unlist(x[ mcdCols ])
for (aCofactor in cofactors) {
evidence <- c(evidence, cleanICDs(paste(aCofactor, as.character(x[,aCofactor]), sep='.')))
}
result = bayesCompute(evidence=evidence, ...)$naiveBayesVec
return(names(sort(result, decreasing=TRUE))[1])
}
#bestCall.2(x=dat[16,], mcdCols=mcdCols, cofactors=c('ageGroup', 'gender'), probObj=probObj)
#someRows <- sample(nrow(dat),50)         # sample just 50 rows
#someRows <- which(dat$icd_name=='_gc')   # try just the _gc data
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c('ageGroup', 'gender'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
goodCols <- c(1,4,10,12:17, which(names(dat) %in% c("age", 'ageGroup',"gender", "education", 
"cigsPerDay", 'smokingGroup')))
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c('ageGroup', 'gender'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
sum(datBayes$gs_text == datBayes$naiveBayes); nrow(datBayes)
accuCount = ddply(datBayes, .(gs_text), summarize, count=length(gs_text), trainingCount=sum(icd_name!='_gc'),
correct=sum(gs_text==naiveBayes), sens=correct/count)
plot(accuCount$count, accuCount$sens, main='Sensitivty as a function of the number of cases')
abline(reg=lm(accuCount$sens ~ accuCount$count), col='red', lty=2)
plot(accuCount$count, accuCount$sens, main='Sensitivty as a function of the number of cases')
abline(reg=lm(accuCount$sens ~ accuCount$count), col='red', lty=2)
write.csv(accuCount, file='accuCount.csv', quote=FALSE)  # save it for perusal in Excel & etc
# Graphically depict which choices were made in the transitions
temp1 = temp2 = datBayes
inx = sample(nrow(temp1))
labelCodes =  sort(unique(datBayes$gs_text, datBayes$naiveBayes))
temp1$x   = 1
temp1$y   = factor(datBayes$gs_text, labels=labelCodes, levels=labelCodes)
temp2$x   = 2
temp2$y   = factor(datBayes$naiveBayes, labels=labelCodes, levels=labelCodes)
temp      = rbind(temp1[inx,], temp2[inx,])
sugarDat           <- data.frame(id=sort(unique(temp$sid)), pch=NA, col=NA)
rownames(sugarDat) <- sugarDat$id
sugarDat$pch       <- c(70, 77)[ map(temp$sid, temp$gender=='Male')+1 ]   # M and F unicode symbols!
sugarDat$col       <- brewer.pal(n=3, name="Dark2")[ map(temp$sid, temp$icd_name=='_gc')+1 ]  
pdf(file='Info_and_Results/Prediction_calls_constant_Machine.pdf', height=11, width=17)
# First, panel by the gs_text listing
xyplot(jitter(as.numeric(y)) ~ jitter(x, amount=0.05) | gs_text, groups=sid, data=temp, type=c('p', 'l', 'g'), as.table=TRUE,
scales=list(y=list(labels=as.character(temp$y), at=as.numeric(temp$y), alternating=3, cex=0.4),
            x=list(draw=FALSE)),
par.strip.text=list(lines=0.8, cex=0.7),
alpha=0.3, pch=sugarDat$pch, col=sugarDat$col, 
ylab='', xlab='', main='gs_text  --->  naiveBayes')
# Then, panel by the Bayes prediction
xyplot(jitter(as.numeric(y)) ~ x | naiveBayes, groups=sid, data=temp, type=c('p', 'l', 'g'), as.table=TRUE,
scales=list(y=list(labels=as.character(temp$y), at=as.numeric(temp$y), alternating=3, cex=0.4),
            x=list(draw=FALSE)),
par.strip.text=list(lines=0.8, cex=0.7),
alpha=0.3, pch=sugarDat$pch, col=sugarDat$col, 
ylab='', xlab='', main='gs_text  --->  naiveBayes')
dev.off()
ddply(datBayes[inx,], .(naiveBayes), summarize, res=length(gs_text))
inx <- datBayes$gs_text == 'Pneumonia'
datBayes[inx, ]
ddply(datBayes[inx,], .(naiveBayes), summarize, res=length(gs_text))
str(probObj)
QnBayes[,'Pneumonia']
probObj$QnBayes[,'Pneumonia']
sort(probObj$QnBayes[,'Pneumonia'])
plot(sort(probjObj$QnBayes[,'Pneumonia']))
plot(sort(probObj$QnBayes[,'Pneumonia']))
plot(sort(probObj$QnBayes[,'Pneumonia']), log='y')
plot(sort(probObj$QnBayes[,'Pneumonia']), log='y'); grid()
points(sort(probObj$QnBayes[,'Diabetes']), col='blue')
plot(sort(probObj$QnBayes[,'Pneumonia'])); grid()
points(sort(probObj$QnBayes[,'Diabetes']), col='blue')
points(sort(probObj$QnBayes[,'Stillbirth']), col='red')
points(sort(probObj$QnBayes[,'AIDS']), col='grey')
plot(sort(probObj$QnBayes[,'Pneumonia']), xlim=c(400,probObj$dimQ[1])); grid()
points(sort(probObj$QnBayes[,'Diabetes']), col='blue')
points(sort(probObj$QnBayes[,'Stillbirth']), col='red')
points(sort(probObj$QnBayes[,'AIDS']), col='grey')
plot(sort(probObj$QnBayes[,'Pneumonia']), xlim=c(400, probObj$dimQ[1]+10)); grid()
points(sort(probObj$QnBayes[,'Diabetes']), col='blue')
points(sort(probObj$QnBayes[,'Stillbirth']), col='red')
points(sort(probObj$QnBayes[,'AIDS']), col='grey')
probObj$dimQ[1]
str(probObj)
points(sort(probObj$QnBayes[,'Stillbirth']),                    col='pink')  # very poor sens
sort(probObj$QnBayes[,'Other.Cardiovascular.Diseases'])
plot(sort(probObj$QnBayes[,'Pneumonia']), xlim=c(400, probObj$dimQ[1]+10)); grid()  # very poor sens
points(sort(probObj$QnBayes[,'Stillbirth']),                    col='green')  # very poor sens
points(sort(probObj$QnBayes[,'Other.Cardiovascular.Diseases']), col='red')    # very poor sens
points(sort(probObj$QnBayes[,'AIDS']), col='grey')       # very good sens
points(sort(probObj$QnBayes[,'Diabetes']), col='blue')   # very good sens
inx <- datBayes$gs_text == 'Pneumonia'
datBayes[inx, ]
datBayes[inx, ]
inx <- which(datBayes$gs_text == 'Pneumonia')
inx <- inx[ order(datBayes[inx,'naiveBayes']) ]
datBayes[inx, ]
icdGuess(' J180', 'J960')
icdGuess(c(' J180', 'J960'))
icdGuess(c(' J189', 'J960'))
icdGuess(c('G931','K566', 'N189', 'I10','D849'))
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c('gender'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
sum(datBayes$gs_text == datBayes$naiveBayes); nrow(datBayes)
accuCount = ddply(datBayes, .(gs_text), summarize, count=length(gs_text), trainingCount=sum(icd_name!='_gc'),
correct=sum(gs_text==naiveBayes), sens=correct/count)
plot(accuCount$count, accuCount$sens, main='Sensitivty as a function of the number of cases')
abline(reg=lm(accuCount$sens ~ accuCount$count), col='red', lty=2)
accuCount
# Graphically depict which choices were made in the transitions
temp1 = temp2 = datBayes
inx = sample(nrow(temp1))
labelCodes =  sort(unique(datBayes$gs_text, datBayes$naiveBayes))
temp1$x   = 1
temp1$y   = factor(datBayes$gs_text, labels=labelCodes, levels=labelCodes)
temp2$x   = 2
temp2$y   = factor(datBayes$naiveBayes, labels=labelCodes, levels=labelCodes)
temp      = rbind(temp1[inx,], temp2[inx,])
sugarDat           <- data.frame(id=sort(unique(temp$sid)), pch=NA, col=NA)
rownames(sugarDat) <- sugarDat$id
sugarDat$pch       <- c(70, 77)[ map(temp$sid, temp$gender=='Male')+1 ]   # M and F unicode symbols!
sugarDat$col       <- brewer.pal(n=3, name="Dark2")[ map(temp$sid, temp$icd_name=='_gc')+1 ]  
pdf(file='Info_and_Results/Prediction_calls_gender_only_cofactor.pdf', height=11, width=17)
# First, panel by the gs_text listing
xyplot(jitter(as.numeric(y)) ~ jitter(x, amount=0.05) | gs_text, groups=sid, data=temp, type=c('p', 'l', 'g'), as.table=TRUE,
scales=list(y=list(labels=as.character(temp$y), at=as.numeric(temp$y), alternating=3, cex=0.4),
            x=list(draw=FALSE)),
par.strip.text=list(lines=0.8, cex=0.7),
alpha=0.3, pch=sugarDat$pch, col=sugarDat$col, 
ylab='', xlab='', main='gs_text  --->  naiveBayes')
# Then, panel by the Bayes prediction
xyplot(jitter(as.numeric(y)) ~ x | naiveBayes, groups=sid, data=temp, type=c('p', 'l', 'g'), as.table=TRUE,
scales=list(y=list(labels=as.character(temp$y), at=as.numeric(temp$y), alternating=3, cex=0.4),
            x=list(draw=FALSE)),
par.strip.text=list(lines=0.8, cex=0.7),
alpha=0.3, pch=sugarDat$pch, col=sugarDat$col, 
ylab='', xlab='', main='gs_text  --->  naiveBayes')
dev.off()
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c('gender'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
# BASIC SENSITIVITY AND SPECIFICITY
sum(datBayes$gs_text == datBayes$naiveBayes); nrow(datBayes)
accuCount = ddply(datBayes, .(gs_text), summarize, count=length(gs_text), trainingCount=sum(icd_name!='_gc'),
correct=sum(gs_text==naiveBayes), sens=correct/count)
plot(accuCount$count, accuCount$sens, main='Sensitivty as a function of the number of cases')
abline(reg=lm(accuCount$sens ~ accuCount$count), col='red', lty=2)
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c('gender' 'ageGroup'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
#write.csv(datBayes, file='datBayes.csv', quote=FALSE)  # save it for perusal in Excel & etc
#save(datBayes, file='datBayes.RData')                  # save it for further R work
# BASIC SENSITIVITY AND SPECIFICITY
sum(datBayes$gs_text == datBayes$naiveBayes); nrow(datBayes)
accuCount = ddply(datBayes, .(gs_text), summarize, count=length(gs_text), trainingCount=sum(icd_name!='_gc'),
correct=sum(gs_text==naiveBayes), sens=correct/count)
plot(accuCount$count, accuCount$sens, main='Sensitivty as a function of the number of cases')
abline(reg=lm(accuCount$sens ~ accuCount$count), col='red', lty=2)
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
# BASIC SENSITIVITY AND SPECIFICITY
sum(datBayes$gs_text == datBayes$naiveBayes); nrow(datBayes)
accuCount = ddply(datBayes, .(gs_text), summarize, count=length(gs_text), trainingCount=sum(icd_name!='_gc'),
correct=sum(gs_text==naiveBayes), sens=correct/count)
plot(accuCount$count, accuCount$sens, main='Sensitivty as a function of the number of cases')
abline(reg=lm(accuCount$sens ~ accuCount$count), col='red', lty=2)
accuCount
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
#cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c(''), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
# A minifunction for ddply that takes in 1 line of dat
bestCall.2 <- function(x, mcdCols, cofactors, ...) {
evidence = unlist(x[ mcdCols ])
if (! missing(cofactors)) {
for (aCofactor in cofactors) {
evidence <- c(evidence, cleanICDs(paste(aCofactor, as.character(x[,aCofactor]), sep='.')))
}
}
result = bayesCompute(evidence=evidence, ...)$naiveBayesVec
return(names(sort(result, decreasing=TRUE))[1])
}
#bestCall.2(x=dat[16,], mcdCols=mcdCols, cofactors=c('ageGroup', 'gender'), probObj=probObj)
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
#cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
bestCall.2(x=dat[16,], mcdCols=mcdCols, cofactors=c('ageGroup', 'gender'), probObj=probObj)
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51")
bestCall.2(x=dat[16,], mcdCols=mcdCols, cofactors=c('ageGroup', 'gender'), probObj=probObj)
sum(datBayes$gs_text == datBayes$naiveBayes); nrow(datBayes)
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
head(datBayes)
which(is.na(datBayes[naiveBayes]))
which(is.na(datBayes$naiveBayes]))
which(is.na(datBayes$naiveBayes))
datBayes$naiveBayes
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
#cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
which(is.na(datBayes$naiveBayes))
datBayes[475:480,]
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
#cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes[475:480,]
# A minifunction for ddply that takes in 1 line of dat
bestCall.2 <- function(x, mcdCols, cofactors, ...) {
evidence = unlist(x[ mcdCols ])
if (! missing(cofactors)) {
for (aCofactor in cofactors) {
evidence <- c(evidence, cleanICDs(paste(aCofactor, as.character(x[,aCofactor]), sep='.')))
print(length(evidence))
}
}
result = bayesCompute(evidence=evidence, ...)$naiveBayesVec
return(names(sort(result, decreasing=TRUE))[1])
}
bestCall.2(x=dat[16,], mcdCols=mcdCols, cofactors=c('ageGroup', 'gender'), probObj=probObj)
# A minifunction for ddply that takes in 1 line of dat
bestCall.2 <- function(x, mcdCols, cofactors, ...) {
evidence = unlist(x[ mcdCols ])
if (! missing(cofactors)) {
for (aCofactor in cofactors) {
evidence <- c(evidence, cleanICDs(paste(aCofactor, as.character(x[,aCofactor]), sep='.')))
}
}
print(length(evidence))
result = bayesCompute(evidence=evidence, ...)$naiveBayesVec
return(names(sort(result, decreasing=TRUE))[1])
}
bestCall.2(x=dat[16,], mcdCols=mcdCols, cofactors=c('ageGroup', 'gender'), probObj=probObj)
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
#cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
args(cleanIcds)
args(cleanICDs)
# A minifunction for ddply that takes in 1 line of dat
bestCall.2 <- function(x, mcdCols, cofactors, ...) {
evidence = cleanICDs(unlist(x[ mcdCols ]))
if (! missing(cofactors)) {
for (aCofactor in cofactors) {
evidence <- c(evidence, cleanICDs(paste(aCofactor, as.character(x[,aCofactor]), sep='.')))
}
}
print(length(evidence))
result = bayesCompute(evidence=evidence, ...)$naiveBayesVec
return(names(sort(result, decreasing=TRUE))[1])
}
bestCall.2(x=dat[16,], mcdCols=mcdCols, cofactors=c('ageGroup', 'gender'), probObj=probObj)
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
#cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
sum(datBayes$gs_text == datBayes$naiveBayes); nrow(datBayes)
datBayes <- dat[,goodCols]   # process the whole shebang
datBayes$naiveBayes <- NA
for (i in 1:nrow(datBayes)) {
datBayes[i,'naiveBayes'] <- bestCall.2(x=datBayes[i,], 
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"), 
cofactors=c('gender', 'ageGroup'), 
probObj=probObj)
}
datBayes <- cbind(datBayes[,1:3], naiveBayes=datBayes[,ncol(datBayes)], datBayes[,4:(ncol(datBayes)-1)])
datBayes$gs_text <- make.names(datBayes$gs_text)
head(datBayes)
# 10/27/14  - Blows a gasket if no cofactors and sid=762,  (Infant), and does it serially...??
datBayes$naiveBayes
sum(datBayes$gs_text == datBayes$naiveBayes); nrow(datBayes)
icdGuess('K639')
icdGuess('X700')
icdGuess('T71')
icdGuess('T710')
rm(list=ls())
q()
# Details of the ICD codes:
# http://en.wikipedia.org/wiki/ICD-10
# http://en.wikipedia.org/wiki/ICD-10_Chapter_XX:_External_causes_of_morbidity_and_mortality
# CMS32_DESC_LONG_DX.txt  ICD9 codes
# icd10cm_order_2015.txt  ICD10 codes
rm(list=ls())
setwd('C:/Users/John/Desktop/DeathCertificates/')
library(lattice)
library(latticeExtra)
library(plyr)
library(gplots)
library(ggplot2)
library(gtools)       # smartbind  (to bind dfs with different columns)
library(edgeR)        # Good-Turing estimator background for transition matrix
source('GC Methods.R')
# -----------------------------------------------
# Start by reading in the Mexico death certificate data.   This supposedly has the data from 1589 Mexican
# subjects.   These are 'gold standard' reviewed documents and 224 of them are noted as being garbage codes.
# Prep the data in the other script file, 'DeathCertificates_Basic_Data_Shaping_and_Storage.R'
load(file='dat.RData')          # Load the (1587x67) data as processed in earlier
load(file='datBayes.RData')     # In development.   Most recent predictions
load(file='icd10Vec.RData')     # 91,737 ICD-10 definitions
load(file='colDesc.RData')      # Descriptions of the column headers (547 headers as a named vector)
count(dat$gs_text)
dim(dat)
source('GC Methods.R')
goodCols <- c(1,4,10,12:17, which(names(dat) %in% c("age", 'ageGroup',"gender", "education", 
"cigsPerDay", 'smokingGroup')))
someIds <- sample(dat$sid[dat$icd_name != '_gc'])
dat[dat$sid %in% someIds[10:15], goodCols]
#   First, build the transition matrix
x=dat[dat$sid %in% someIds,]
probObj  <- getMCDTransitionMatrix(x=x, priorFunction='Good-Turing',
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"),
finalCause="gs_text", cofactors=c('gender', 'ageGroup', 'smokingGroup'))
source('GC Methods.R')
probObj  <- getMCDTransitionMatrix(x=x, priorFunction='Good-Turing',
mcdCols=c("codcau11", "codcau21", "codcau31", "codcau41", "codcau51"),
finalCause="gs_text", cofactors=c('gender', 'ageGroup', 'smokingGroup'))
probObj$rawMat
str(probObj)
sort(probObj$codVec)
probObj$rawMat[probObj$codVec > 30, 1:5]
str(probObj)
icdGuess('A419')
icdGuess('E872')
icdGuess('E878')
'
icdGuess('B24')
icdGuess('J189')
icdGuess('J960')
dim(dat)
str(probObj)
1587 -1363
names(dat)
 probObj$QnBayes[probObj$codVec > 30, 1:5]
signif( probObj$QnBayes[probObj$codVec > 30, 1:5], 3)
0.212  0.0674 * 0.146 
0.212 * 0.0674 * 0.146 
7.57e-03 * 2.25e-02  *   1.41e-03  
q()
